void round_robbin() {
	int p_time = 5;

	// go through the queue until all progams have finished


	// pop from queue, and load program
	for (int i = 0; i < p_time; i++) {
		// run progam
	}
	// add to queue if program isnt fihisned, and unload program 

}

void dynamic_round_robbin() {
	// sort of a mix between shortest first, and round robbin
	// will iterate through a queue with a maximum timeslice, 
	// but will be more generous with task that are close to completion. 


	int p_time = 5;
	int p_overtime = 5;

	int cycle_average_instructions
		void cycle;
	void new_cycle;

}

void shortest_first() {
	// sort queue

	// run till finish
}